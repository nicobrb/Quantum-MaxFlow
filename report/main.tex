\documentclass{article}
\usepackage[italian]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{float}

\author{Nicola Barbaro (1070668)\\Mario Bifulco (881727)}
\title{Progetto OC - \emph{Max-Flow} QUBO}
\date{A.A. 2022/2023}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte 1 MaxFlow MinCut th
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problema del flusso massimo}

\subsection{Descrizione generale del problema}
Introdotto da Harris e Ross nel 1954, il problema del Flusso Massimo (Maximum Flow Problem) richiede di trovare, sulla struttura dati chiamata Rete di Flusso, un
flusso plausibile con il rapporto più alto possibile (chiamato, appunto \emph{Flusso Massimo}). Il MF è spesso usato per risolvere problemi legati al trasporto di beni o di 
instradamento di informazioni su una rete.

Si vuole definire innanzitutto la connotazione della Rete di Flusso. Sia:
\begin{itemize}
    \item $G = (V, E)$ una rete (rappresentata come un grafo) con $s, t \in V$ rispettivamente la \emph{fonte} e la \emph{foce} di $G$.
    \item Dato $(i, j) \in E$ uno qualsiasi spigolo della rete, la sua \textbf{capacità} è definita come la massima quantità di flusso che può passare per esso. 
    Il suo valore è definito dalla funzione $c : E \rightarrow \mathbb{R}^+$.
\end{itemize}

\textbf{Definizione.} Un generico flusso su una rete $G = (V, E)$ è una funzione $f : E \rightarrow \mathbb{R}$ se sono soddisfatti i seguenti:
\begin{itemize}
    \item \emph{Vincoli di capacità.} Per ogni $(i, j) \in E$, il flusso associato ad esso non superà mai la sua capacità, ossia $x_{ij} \leq u_{ij}$.
    \item \emph{Conservazione dei flussi.} Con sola esclusione del nodo fonte $s$ e foce $t$, la somma dei flussi in entrata in un nodo deve uguagliare la somma dei flussi in uscita
    dallo stesso nodo. In formula:

    \[ \forall v \in V \backslash \{s,t\}: \sum_{i: (i, j) \in E} x_{ij} = \sum_{i: (j,i) \in E} x_{ji}\]
\end{itemize}
Si può osservare come la matrice di adiacenza del flusso G è antisimmetrica: infatti $x_{ij} = -x_{ji},$ $\forall (i, j) \in E$.

\paragraph{Definizione.} Il \textbf{valore} del flusso è la quantità di flusso passante sulla rete a partire dalla fonte $s$ e terminante nella foce $t$. Rappresentato in 
termini formali, un flusso $f : E \rightarrow \mathbb{R}^+$ è una funzione il cui dominio è dato da:

\[ \lvert x \rvert = \sum_{j: (s,j) \in E} x_{sj} - \sum_{i: (i,s) \in E} x_{is}\]

A questo punto è possibile fornire una introduzione formale del problema attraverso la seguente:\\
\pagebreak

\paragraph{Definizione.} Il \textbf{Problema del Flusso Massimo} è il problema di instradare quanto più flusso possibile dalla fonte alla foce, ossia di trovare il flusso con massimo valore $x_{max}$ instradabile sulla rete.

Il problema del flusso massimo ammette unica o infinite soluzioni, dato che ci sono infinite combinazioni lineari possibili del valore $x_{max}$ di partenza.


\subsection{Minimum Cut, Teorema \emph{Max-Flow Min-Cut}} \label{min-cut}
Nella teoria dei grafi, un \textbf{taglio di costo minimo} (o \textbf{minimum cut}) per un grafo è un partizione dei vertici del grafo in due insiemi disgiunti minimale rispetto
ad una qualunque metrica definita dal problema. Nella specifica del problema di Flusso a Costo Massimo, su rete G, è interessante porre l'attenzione sull'insieme di tagli chiamati 
\textbf{tagli s-t} $C = (S,T)$: questo insieme è una suddivisione dei vertici V di G tale che il nodo fonte $s \in S$ e il nodo foce $t \in T$, ossia una ripartizione dei vertici
della rete in due parti, con la fonte in una parte e la foce in un'altra. 
Si definisce il \textbf{cut-set} $X_C$ di un taglio C l'insieme degli spigoli che connettono i vertici $i \in S$ ai vertici $j \in T$:

\[X_C := \{(i, j) \in E : i \in S, j \in T \} = (S \times T) \cap E\]

È immediato notare che togliere gli spigoli di $X_C$ da E renderebbe impossibile la computazione di qualsiasi flusso a valore positivo, perché non ci sarebbero più cammini dalla 
fonte alla foce percorribili.

La \textbf{capacità} di un taglio $s-t$ è dato dalla somma delle capacità degli spigoli in $X_C$:

\[c(S,T) = \sum_{(i, j) \in X_{C}} u_{ij} = \sum_{(i,j) \in E, i \in S, j \in T} u_{ij} \]

Il problema del \textbf{taglio s-t a costo minimo} prevede di minimizzare $u(S,T)$, ossia di determinare $S, T$ tali che la capacità del taglio $s-t$ sia minimale.

\paragraph{Teorema \emph{Max-Flow Min-Cut} (1).} Il massimo valore di un flusso $s-t$ è uguale al taglio $s-t$ di costo minimo tra tutti i possibili tagli.\cite{Ford:1956:MFT}
\pagebreak

\subsection{Riformulazione su programmazione lineare primale-duale}

È possibile rappresentare il problema del Flusso a Costo massimo come un programma lineare primale il cui duale è il programma lineare associato al problema di Taglio a Costo Minimo.

\textbf{Formulazione Primale (a).}

\begin{equation*}
    \begin{array}{ll@{}ll}
    \text{massimizza}   & \displaystyle\sum_{(s, i) \in FS_{i}} x_{si} = x_{ts} & \;\;\;\;\;\;\;\;\; &(1)\\
    \text{soggetto a}   & \displaystyle\sum_{(h, i) \in BS_{i}} x_{hi} - \sum_{(i, h) \in FS_{i}} x_{ij} = 0 \;\;\;\;\;\;\;\;\; &    \forall i \in V \backslash \{s,t\}&(2)\\
                        & (\displaystyle\sum_{(i, t) \in BS_{t}} x_{it}) - x_{ts} = 0 & &(3)\\
                        &  x_{ts} - (\displaystyle\sum_{(s,i) \in FS_{s}} x_{si}) = 0 & &(4)\\
                        &0 \leq x_{ij} \leq u_{ij} & \forall (i,j) \in E &(5).
    \end{array}
    \end{equation*}
I vincoli hanno la seguente interpretazione:
\begin{enumerate}
    \item Si vuole massimizzare il flusso su un arco \emph{dummy}, senza capacità, che va dalla foce $t$ alla fonte $s$;
    \item Vincoli che permettono di rispettare la \emph{conservazione dei flussi};
    \item Il flusso massimo trovato dal problema deve combaciare con la somma dei flussi entranti nella foce
    \item Il flusso massimo trovato dal problema deve combaciare con la somma dei flussi uscenti dalla fonte
    \item Bisogna rispettare il \emph{vincolo di capacità}.
\end{enumerate}

Il duale di un programma lineare primale è definibile attraverso il seguente procedimento:
\begin{itemize}
    \item Ogni variabile del primale diventa un vincolo del duale;
    \item Ogni vincolo del primale diventa una variabile del duale;
    \item Va invertita la funzione obiettivo (da massimo a minimo, o viceversa).
\end{itemize} 

Secondo questo algoritmo, possiamo ottenere a partire da \textbf{(a)}, la seguente:
\textbf{Formulazione Duale (b).}
\begin{equation*}
    \begin{array}{ll@{}ll}
    \text{minimizza}    & \displaystyle\sum_{(i, j) \in E} \omega_{ij}u_{ij} &  &(1)\\
    \text{soggetto a}   & \displaystyle \pi_t - \pi_s \geq 1 &   &(2)\\
                        & \displaystyle \pi_i - \pi_j  + \omega_{ij} \geq 0\;\;\;\;\;\;\;\;\; & \forall (i,j) \in E & (3)\\
                        & \displaystyle \omega_{ij} \geq 0 & \forall (i,j) \in E & (4).\\

    \end{array}
    \end{equation*}

Ove:

\begin{equation}
    \omega_{ij} =
        \begin{cases}
        1 & \text{se $i \in S$ e $j \in T$, ossia lo spigolo (i,j) appartiene al taglio $X_C$}\\
        0 & \text{altrimenti}
        \end{cases}       
\end{equation}

\begin{equation}
    \pi_{i} =
        \begin{cases}
        1 & \text{se $i \in T$}\\
        0 & \text{altrimenti}
        \end{cases}       
\end{equation}

Anche in questo caso è possibile fornire una interpretazione dei vincoli e della funzione obiettivo:
\begin{enumerate}
    \item La funzione obiettivo vuole minimizzare la capacità totale degli spigoli nel taglio;
    \item Il vincolo si assicura che la fonte sia nell'insieme $S$ e la foce sia nell'insieme $T$;
    \item Garantisce che, per ogni nodo $i, j$ diverso dalla fonte o dalla foce, se $i \in S$ e $j \in T$, allora lo spigolo $(i,j)$ deve essere considerato nel taglio
    (e quindi $\omega_{ij}\geq 1$);
    \item triviale.
\end{enumerate}

Si può osservare come il problema non garantisce quali spigoli non siano nel taglio, ma può solo garantire che, se esso \emph{può} ricadere nel taglio, allora la sua capacità
deve essere sommata nella funzione obiettivo: è deducibile che ogni possibile taglio $s-t$ vede il suo costo come una soluzione ammissibile per \textbf{(b)}, e, dalla teoria, ogni
soluzione di \textbf{(b)} è un limite superiore per \textbf{(a)}, e quindi per il valore del flusso che stiamo cercando di massimizzare.
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte 2 Problemi QUBO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{QAC e formulazione QUBO}
La seguente sezione fa riferimento alle informazioni contenute in \cite{MCGEOCH2020169} e \cite{DBLP:journals/corr/abs-1811-11538}.

\subsection{Quantum Adiabatic Computing}
La risoluzione di problemi intrattabili in modo efficiente utilizzando il calcolo classico richiede la dimostrazione dell'uguaglianza $P = NP$. Tuttavia, al momento attuale, questa dimostrazione rimane un problema aperto.

Un'alternativa per affrontare tali problemi è sfruttare modelli di calcolo non convenzionali che utilizzano principi di calcolo differenti. Tra questi modelli, si trovano le architetture basate sulla meccanica quantistica.

Attualmente, i due principali approcci per la computazione quantistica sono la programmazione tramite gate, concettualmente simile alla programmazione tramite porte logiche, e la programmazione adiabatica quantistica (QAC). Quest'ultimo approccio si basa sulla ricerca di stati a minore energia per trovare la soluzione desiderata.

Nel modello di calcolo descritto da QAC, si utilizza una matrice Hermitiana con elementi complessi ($\mathbb{C}$). Gli Hamiltoniani, utilizzati per eseguire la computazione, rappresentano il livello di energia istantaneo di un sistema fisico e descrivono l'evoluzione del suo stato.

L'idea fondamentale è sfruttare le proprietà fisiche per cercare stati a minore energia e quindi più stabili.

La matrice Hamiltoniana è un operatore in uno spazio vettoriale in cui le configurazioni delle variabili sono rappresentate come vettori, che rappresentano gli autovettori della matrice, e i valori assunti dalla funzione da minimizzare corrispondono agli autovalori di $\mathcal{H}_P$. 

Per risolvere problemi espressi tramite la programmazione lineare utilizzando un Quantum CPU, è necessario convertirli in una formulazione QUBO (Quantum Unconstraint Binary Optimization), che presenta una naturale rappresentazione grafica in forma di grafo, successivamente mappato nel grafo dei qubit.

\begin{figure}
\begin{center}
    \begin{tikzpicture}[main/.style = {draw, circle}] 
        \node[main](1){};
        \node[main](2)[right of=1]{}; 
        \node[main](5)[above right of=2]{};
        \node[main](6)[above of=5]{};
        \node[main](3)[below right of=5]{};
        \node[main](4)[right of=3]{};
        \node[main](7)[below right of=2]{};
        \node[main](8)[below of=7]{};

        \draw (1) -- (6);\draw (6) -- (4);\draw (4) -- (8);\draw (8) -- (1);
        \draw (1) -- (5);\draw (5) -- (4);\draw (4) -- (7);\draw (7) -- (1);
        \draw (6) -- (2);\draw (2) -- (8);\draw (8) -- (3);\draw (3) -- (6);
        \draw (2) -- (5);\draw (5) -- (3);\draw (3) -- (7);\draw (7) -- (2);

        \node[main](11)[right of=4]{};
        \node[main](12)[right of=11]{}; 
        \node[main](15)[above right of=12]{};
        \node[main](16)[above of=15]{};
        \node[main](13)[below right of=15]{};
        \node[main](14)[right of=13]{};
        \node[main](17)[below right of=12]{};
        \node[main](18)[below of=17]{};

        \draw (11) -- (16);\draw (16) -- (14);\draw (14) -- (18);\draw (18) -- (11);
        \draw (11) -- (15);\draw (15) -- (14);\draw (14) -- (17);\draw (17) -- (11);
        \draw (16) -- (12);\draw (12) -- (18);\draw (18) -- (13);\draw (13) -- (16);
        \draw (12) -- (15);\draw (15) -- (13);\draw (13) -- (17);\draw (17) -- (12);

        \node[main](26)[below of=8]{};
        \node[main](25)[below of=26]{};
        \node[main](22)[below left of=25]{};
        \node[main](21)[left of=22]{};
        \node[main](23)[below right of=25]{};
        \node[main](24)[right of=23]{};
        \node[main](27)[below right of=22]{};
        \node[main](28)[below of=27]{};

        \draw (21) -- (26);\draw (26) -- (24);\draw (24) -- (28);\draw (28) -- (21);
        \draw (21) -- (25);\draw (25) -- (24);\draw (24) -- (27);\draw (27) -- (21);
        \draw (26) -- (22);\draw (22) -- (28);\draw (28) -- (23);\draw (23) -- (26);
        \draw (22) -- (25);\draw (25) -- (23);\draw (23) -- (27);\draw (27) -- (22);

        \node[main](36)[below of=18]{};
        \node[main](35)[below of=36]{};
        \node[main](32)[below left of=35]{};
        \node[main](31)[left of=32]{};
        \node[main](33)[below right of=35]{};
        \node[main](34)[right of=33]{};
        \node[main](37)[below right of=32]{};
        \node[main](38)[below of=37]{};

        \draw (31) -- (36);\draw (36) -- (34);\draw (34) -- (38);\draw (38) -- (31);
        \draw (31) -- (35);\draw (35) -- (34);\draw (34) -- (37);\draw (37) -- (31);
        \draw (36) -- (32);\draw (32) -- (38);\draw (38) -- (33);\draw (33) -- (36);
        \draw (32) -- (35);\draw (35) -- (33);\draw (33) -- (37);\draw (37) -- (32);

        \draw[ultra thick] (6) -- (16);
        \draw[ultra thick] (5) -- (15);
        \draw[ultra thick] (7) -- (17);
        \draw[ultra thick] (8) -- (18);
        \draw[ultra thick] (26) -- (36);
        \draw[ultra thick] (25) -- (35);
        \draw[ultra thick] (27) -- (37);
        \draw[ultra thick] (28) -- (38);
        \draw[ultra thick] (1) -- (21);
        \draw[ultra thick] (2) -- (22);
        \draw[ultra thick] (3) -- (23);
        \draw[ultra thick] (4) -- (24);
        \draw[ultra thick] (11) -- (31);
        \draw[ultra thick] (12) -- (32);
        \draw[ultra thick] (13) -- (33);
        \draw[ultra thick] (14) -- (34);
    \end{tikzpicture} 
    \caption{Esempio di QCPU a 32 qubit}
\end{center}
\end{figure}

La mappatura viene effettuata mediante l'utilizzo dell'algoritmo \emph{minor embedding} che preserva le relazioni aggiungendo eventualmente nuovi nodi se necessario. Pur appertenendo alla classe NP-complete tale algoritmo, viene risolto in modo efficiente nel caso medio, rendendolo quindi valido nell'utilizzo pratico.

Ci sono alcuni punti critici da considerare in questo approccio computazionale:

\begin{itemize}
    \item È difficile fornire un limite inferiore al tempo di annealing (il tempo minimo necessario per raggiungere lo stato finale).
    \item In assenza di tale limite inferiore, la formulazione QUBO può essere considerata come un'euristica e non è possibile valutare in generale l'efficienza e la correttezza dell'algoritmo.
    \item Questo approccio non è valido in modo generale, poiché ci sono casi in cui gli algoritmi classici mostrano un comportamento lineare, mentre l'implementazione quantistica può degradare all'aumentare delle dimensioni del problema.
\end{itemize}
\pagebreak

\subsection{Quadratic Unconstraint Binary Optimization}
Il problema QUBO, Quadratic Unconstrained Binary Optimization, consiste nell'individuare il vettore $x^* = (x_1^*, \dots, x_n^*)$ che minimizza l'equazione $\bar{x}^tQ\bar{x}$, dove $\bar{x}$ è un vettore colonna di variabili binarie e $Q$ è una matrice triangolare superiore che rappresenta i coefficienti della funzione da minimizzare.

In particolare, l'obiettivo del problema QUBO è determinare il valore delle variabili binarie $x_i$ che minimizza l'espressione $\sum_{i=1}^{n} \sum_{j=1}^{n} Q_{ij} x_i x_j$, dove $Q_{ij}$ sono gli elementi della matrice $Q$.

\begin{center}
    minimizzare 
    $\underbrace{\begin{bmatrix}
        x_1 & \cdots & x_n 
    \end{bmatrix}}_{\bar{x}^T}$ 
    $\underbrace{\begin{bmatrix}
        a_1 & \cdots & a_3 \\
        \vdots & \ddots & b_3 \\
        0 & \cdots & c_3 
    \end{bmatrix}}_{Q}$ 
    $\underbrace{\begin{bmatrix}
        x_1 \\
        \vdots \\
        x_n 
    \end{bmatrix}}_{\bar{x}}$       
\end{center}

È importante notare che nella funzione obiettivo espansa, è possibile riscrivere i termini quadratici, cioè le variabili al quadrato, utilizzando il loro equivalente lineare. Questa riscrittura è possibile grazie al dominio delle variabili $x_i$, che assumono solo i valori 0 o 1. Pertanto, il termine $x_i^2$ può essere sostituito con $x_i$ nella formulazione del problema QUBO.

Il formalismo dei modelli QUBO offre un approccio flessibile per la risoluzione di problemi di ottimizzazione combinatoria mediante l'utilizzo di variabili binarie e l'espressione quadratica della funzione obiettivo. Questo formalismo è di particolare importanza nella progettazione e nell'implementazione di algoritmi e processori quantistici adiabatici per la risoluzione efficiente di problemi complessi.

\subsection{Simulated Annealing}

L'algoritmo \emph{Simulated Annealing} fornisce una prospettiva intuitiva sul funzionamento di un processore quantistico adiabatico, QCPU.

L'obiettivo di questo algoritmo è raggiungere lo stato finale attraverso un cammino casuale, definito \emph{Random Walk}, esplorando tutti i possibili stati del sistema. La selezione dei passi da compiere è influenzata dalla probabilità che varia nel tempo e determina se accettare o meno le variazioni energetiche del sistema fisico su cui si sta operando.

Nell'implementazione di questo algoritmo, vengono utilizzati due attributi fondamentali: l'insieme degli stati adiacenti a un dato nodo e l'energia associata a tale nodo. Questi parametri influenzano la sequenza di passi che porta al cammino e, dunque, allo stato finale.

Durante l'esecuzione dell'algoritmo, un parametro cruciale è rappresentato dalla temperatura che può decrescere secondo diverse funzioni, più o meno rapidamente. La diminuzione della temperatura comporta una minor propensione al cambio di stato, fino alla stabilizzazione del sistema sulla risposta.

\subsubsection*{Formalizzazione dell'algoritmo \emph{Simulated Annealing}}

Sia $G=(V,E)$ un grafo rappresentante il sistema fisico di interesse, dove $V$ rappresenta l'insieme dei nodi e $E$ l'insieme degli archi. Ogni nodo $v \in V$ ha associata un'energia $E(v)$, mentre l'insieme degli adiacenti di un nodo $v$ è indicato con $N(v)$.

L'algoritmo \emph{Simulated Annealing} può essere descritto attraverso i seguenti passaggi:

\begin{enumerate}
    \item Inizializzazione: si assegna a ogni nodo del grafo una configurazione casuale iniziale e si fissa una temperatura iniziale $T$.
    \item Ciclo principale:
    \begin{enumerate}
        \item Scelta di un nodo $v$ in modo casuale dal grafo.
        \item Selezione di un nodo $u$ in modo casuale dall'insieme $N(v)$.
        \item Calcolo della variazione di energia $\Delta E = E(u) - E(v)$.
        \item Se $\Delta E \leq 0$, si accetta la mossa e si aggiorna lo stato del sistema considerando $u$ come nuovo stato corrente.
        \item Se $\Delta E > 0$, si accetta la mossa con una probabilità $p = \exp(-\frac{\Delta E}{T})$. In caso di accettazione, si aggiorna lo stato del sistema come nel passo precedente.
        \item Ripeti i passi da (a) a (e) fino a soddisfare una condizione di terminazione.
    \end{enumerate}
\end{enumerate}

Durante l'esecuzione dell'algoritmo, la temperatura $T$ viene ridotta nel tempo seguendo una specifica funzione, che dipende dal problema e dall'obiettivo dell'ottimizzazione.

Tale algoritmo rappresenta un importante strumento per l'esplorazione degli spazi di ricerca complessi e ha trovato applicazioni significative nella risoluzione di problemi di ottimizzazione e nell'ambito della computazione quantistica adiabatica.

È importante notare, inoltre, che l'algoritmo può essere implementato anche su processori quantistici adiabatici, sfruttando le peculiarità della computazione quantistica per ottenere potenziali vantaggi prestazionali.
\pagebreak

\section{Min Cut come problema QUBO}

\subsection{Inquadramento del problema}
Come visto nella sezione \ref{min-cut} il problema \emph{Min-Cut} è espresso come:
\begin{center}
\begin{table}[H]
    \centering
    \begin{tabular}{c|c}
        & soggetto a $\pi_t - \pi_s - s_1 = 1$ \\
        minimizzare & $\pi_i - \pi_j + \omega_{ij} - s_2= 0, \forall (i, j) \in E$\\
        $\sum_{(u, v) \in E} \omega_{ij}u_{ij}$ & $\omega_{ij} - s_3 = 0, \forall (i, j) \in E$\\
        & $s_i \geq 0$
    \end{tabular}
\end{table}
\end{center}

Nel quale i vincoli sono stati trasformati in uguaglianze tramite l'aggiunta di apposite variabili di slack.

\begin{center}
\begin{table}[H]
    \centering
    \begin{tabular}{cc}
        $\pi_i = \begin{cases}
            1 & i \in T\\
            0 & \text{altrimenti} \\
        \end{cases}$ 
        & 
        $\omega_{ij} = \begin{cases}
            1 & \text{$(i, j) \in X_C$, archi del taglio}\\
            0 & \text{altrimenti}
        \end{cases}$
    \end{tabular}
\end{table}
\end{center}

Dove la funzione obiettivo è la somma delle capacità degli archi del taglio, mentre i vincoli garantiscono che il taglio sia valido.

L'obiettivo della riformulazione nel problema QUBO è ottenere un'unica equazione $\mathcal{H}_P$ composta solo da variabili binarie e che incorpori sia la funzione obiettivo che i vincoli del problema.

\subsection{Conversione delle variabili di slack}
A differenza delle variabili originali del problema, le variabili di slack non hanno la garanzia di assumere valori binari. Pertanto, è necessario trasformare opportunamente tali variabili per poterle esprimere unicamente attraverso variabili binarie.

La strategia adottata consiste nel convertire ogni variabile di slack utilizzando la relativa rappresentazione in codice binario. I coefficienti delle variabili così introdotte saranno le rispettive potenze di due, consentendo così di rappresentare ogni possibile valore della variabile di slack originale.

Per aggiungere un numero appropriato di variabili binarie, è necessario stimare il valore massimo che le variabili di slack possono assumere. A tal fine, si analizza il limite superiore per ciascuno dei vincoli del problema originale.

Nella riformulazione si useranno le variabili $y_i^j$, dove l'indice $i$ indica il vincolo di riferimento e l'indice $j$ rappresenta la potenza di due corrispondente. Pertanto, la variabile composta, moltiplicata per il suo coefficiente, sarà: $2^jy_i^j$.

\paragraph{Primo vincolo} Riscrivendo il primo vincolo come $s_1 = \pi_t - \pi_s - 1$, per trovare il limite superiore si massimizza la parte destra dell'equazione. Data la natura binaria delle variabili $\pi$, il valore massimo si ottiene azzerando $\pi_s$ e impostando $\pi_t$ a 1, per cui la variabile $s_1$ sarà zero in tutte le istanziazioni che rispettano il primo vincoli, è quindi riscrivibile trivialmente come $y_1^0$. 

\paragraph{Secondo vincolo} Riformulando il secondo vincolo come $s_2 = \pi_i - \pi_j + \omega_{ij}$, il valore massimo si ottiene istanziando $\pi_i$ a uno, $\pi_j$ a zero e $\omega_{ij}$ a uno. In questo modo si ottiene un upper bound pari a due, che viene riformulato come $y_2^0 + 2y_2^1$.

\paragraph{Terzo vincolo} Isolando la variabile di slack nel terzo vincolo, otteniamo $s_3 = \omega_{ij}$. Anche in questo caso, la variabile $s_3$ può assumere solo valori binari, quindi viene sostituita per uniformità di notazione con $y_3^0$.

\subsection{Rilassamento Lagrangiano}
In seguito alla conversione dei vincoli finalizzata a scriverli esclusivamente tramite variabili binarie, è necessario procedere alla riformulazione completa del problema al fine di consentirne l'espressione come un'unica equazione.

A tale scopo è utile applicare una tecnica di rilassamento al problema \emph{Min-Cut}. In particolare, mediante l'uso del rilassamento Lagrangiano, è possibile convertire i vincoli in funzioni penalità che vengono sommate alla funzione obiettivo. Nel problema affrontato le funzioni penalità vengono sommate poiché si sta lavorando su un problema di minimizzazione. Nel caso di problemi di massimo, le penalità verrebbero sottratte.

È importante notare che l'applicazione del rilassamento al problema originale porta all'introduzione di istanziazioni inconsistenti delle variabili, ovvero casi in cui le penalità introdotte non sono sufficientemente elevate e la soluzione minima ottenuta non soddisfa i vincoli originali del problema.

Al fine di evitare tali situazioni, le funzioni penalità vengono moltiplicate per un opportuno parametro, noto come moltiplicatore Lagrangiano. Il suo scopo è garantire che le penalità influiscano in modo significativo sulla formulazione rilassata del problema, in modo da \emph{forzare} l'assegnamento di valori validi che minimizzino la funzione obiettivo.

La riformulazione del problema in forma QUBO diventa quindi:

\begin{center}
    \begin{multline*}
        \min z = \sum_{(u, v) \in E} \omega_{ij}u_{ij} + \lambda*((\pi_t - \pi_s - y_1^0 - 1)^2 +
        \\+ \sum_{(i, j) \in E}(\pi_i - \pi_j + \omega_{ij} - y_2^0 - 2y_2^1)^2 + \sum_{(i, j) \in E}(\omega_{ij} - y_3^0)^2)
    \end{multline*}    
\end{center}

Dove $\lambda$ rappresenta il moltiplicatore Lagrangiano. L'obiettivo è trovare un valore di $\lambda$ adeguato che garantisca che le penalità influiscano in modo significativo sull'assegnamento delle variabili, al fine di ottenere la soluzione ottima anche per il problema non rilassato.
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte 3 Implementazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementazione}

\subsection{Test}
NOTA: possibile dataset per i test \cite{Jensen2022}


\bibliographystyle{plain}
\bibliography{cite}
\end{document}

% ;TODO davvero è costo massimo?