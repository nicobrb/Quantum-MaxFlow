\documentclass{article}
\usepackage[italian]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{tikz}

\author{Nicola Barbaro (1070668)\\Mario Bifulco (881727)}
\title{Progetto OC - MaxFlow QUBO}
\date{A.A. 2022/2023}

\begin{document}

\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte 1 MaxFlow MinCut th
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problema del flusso massimo}
\section{Riformulazione duale - Min cut}
\subsection{Variabili del problema}
\subsection{Significato dei vincoli}
\subsection{Riformulazione tramite uguaglianze}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte 2 Problemi QUBO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{QAC e formulazione QUBO}
La seguente sezione fa riferimento alle informazioni contenute in \cite{MCGEOCH2020169} e \cite{DBLP:journals/corr/abs-1811-11538}.

\subsection{Quantum Adiabatic Computing}
La risoluzione di problemi intrattabili in modo efficiente utilizzando il calcolo classico richiede la dimostrazione dell'uguaglianza $P = NP$. Tuttavia, al momento attuale, questa dimostrazione rimane un problema aperto.

Un'alternativa per affrontare tali problemi è sfruttare modelli di calcolo non convenzionali che utilizzano principi di calcolo differenti. Tra questi modelli, si trovano le architetture basate sulla meccanica quantistica.

Attualmente, i due principali approcci per la computazione quantistica sono la programmazione tramite gate, concettualmente simile alla programmazione tramite porte logiche, e la programmazione adiabatica quantistica (QAC). Quest'ultimo approccio si basa sulla ricerca di stati a minore energia per trovare la soluzione desiderata.

Nel modello di calcolo descritto da QAC, si utilizza una matrice Hermitiana con elementi complessi ($\mathbb{C}$). Gli Hamiltoniani, utilizzati per eseguire la computazione, rappresentano il livello di energia istantaneo di un sistema fisico e descrivono l'evoluzione del suo stato.

L'idea fondamentale è sfruttare le proprietà fisiche per cercare stati a minore energia e quindi più stabili.

La matrice Hamiltoniana è un operatore in uno spazio vettoriale in cui le configurazioni delle variabili sono rappresentate come vettori, che rappresentano gli autovettori della matrice, e i valori assunti dalla funzione da minimizzare corrispondono agli autovalori di $\mathcal{H}_P$. 

Per risolvere problemi espressi tramite la programmazione lineare utilizzando un Quantum CPU, è necessario convertirli in una formulazione QUBO (Quantum Unconstraint Binary Optimization), che presenta una naturale rappresentazione grafica in forma di grafo, successivamente mappato nel grafo dei qubit.

\begin{figure}
\begin{center}
    \begin{tikzpicture}[main/.style = {draw, circle}] 
        \node[main](1){};
        \node[main](2)[right of=1]{}; 
        \node[main](5)[above right of=2]{};
        \node[main](6)[above of=5]{};
        \node[main](3)[below right of=5]{};
        \node[main](4)[right of=3]{};
        \node[main](7)[below right of=2]{};
        \node[main](8)[below of=7]{};

        \draw (1) -- (6);\draw (6) -- (4);\draw (4) -- (8);\draw (8) -- (1);
        \draw (1) -- (5);\draw (5) -- (4);\draw (4) -- (7);\draw (7) -- (1);
        \draw (6) -- (2);\draw (2) -- (8);\draw (8) -- (3);\draw (3) -- (6);
        \draw (2) -- (5);\draw (5) -- (3);\draw (3) -- (7);\draw (7) -- (2);

        \node[main](11)[right of=4]{};
        \node[main](12)[right of=11]{}; 
        \node[main](15)[above right of=12]{};
        \node[main](16)[above of=15]{};
        \node[main](13)[below right of=15]{};
        \node[main](14)[right of=13]{};
        \node[main](17)[below right of=12]{};
        \node[main](18)[below of=17]{};

        \draw (11) -- (16);\draw (16) -- (14);\draw (14) -- (18);\draw (18) -- (11);
        \draw (11) -- (15);\draw (15) -- (14);\draw (14) -- (17);\draw (17) -- (11);
        \draw (16) -- (12);\draw (12) -- (18);\draw (18) -- (13);\draw (13) -- (16);
        \draw (12) -- (15);\draw (15) -- (13);\draw (13) -- (17);\draw (17) -- (12);

        \node[main](26)[below of=8]{};
        \node[main](25)[below of=26]{};
        \node[main](22)[below left of=25]{};
        \node[main](21)[left of=22]{};
        \node[main](23)[below right of=25]{};
        \node[main](24)[right of=23]{};
        \node[main](27)[below right of=22]{};
        \node[main](28)[below of=27]{};

        \draw (21) -- (26);\draw (26) -- (24);\draw (24) -- (28);\draw (28) -- (21);
        \draw (21) -- (25);\draw (25) -- (24);\draw (24) -- (27);\draw (27) -- (21);
        \draw (26) -- (22);\draw (22) -- (28);\draw (28) -- (23);\draw (23) -- (26);
        \draw (22) -- (25);\draw (25) -- (23);\draw (23) -- (27);\draw (27) -- (22);

        \node[main](36)[below of=18]{};
        \node[main](35)[below of=36]{};
        \node[main](32)[below left of=35]{};
        \node[main](31)[left of=32]{};
        \node[main](33)[below right of=35]{};
        \node[main](34)[right of=33]{};
        \node[main](37)[below right of=32]{};
        \node[main](38)[below of=37]{};

        \draw (31) -- (36);\draw (36) -- (34);\draw (34) -- (38);\draw (38) -- (31);
        \draw (31) -- (35);\draw (35) -- (34);\draw (34) -- (37);\draw (37) -- (31);
        \draw (36) -- (32);\draw (32) -- (38);\draw (38) -- (33);\draw (33) -- (36);
        \draw (32) -- (35);\draw (35) -- (33);\draw (33) -- (37);\draw (37) -- (32);

        \draw[ultra thick] (6) -- (16);
        \draw[ultra thick] (5) -- (15);
        \draw[ultra thick] (7) -- (17);
        \draw[ultra thick] (8) -- (18);
        \draw[ultra thick] (26) -- (36);
        \draw[ultra thick] (25) -- (35);
        \draw[ultra thick] (27) -- (37);
        \draw[ultra thick] (28) -- (38);
        \draw[ultra thick] (1) -- (21);
        \draw[ultra thick] (2) -- (22);
        \draw[ultra thick] (3) -- (23);
        \draw[ultra thick] (4) -- (24);
        \draw[ultra thick] (11) -- (31);
        \draw[ultra thick] (12) -- (32);
        \draw[ultra thick] (13) -- (33);
        \draw[ultra thick] (14) -- (34);
    \end{tikzpicture} 
    \caption{Esempio di QCPU a quattro qubit}
\end{center}
\end{figure}

La mappatura viene effettuata mediante l'utilizzo di un algoritmo di \emph{minor-embedding}, che preserva le relazioni aggiungendo eventualmente nuovi nodi se necessario.

Tuttavia, l'algoritmo di \emph{minor-embedding} è NP-completo. Fortunatamente, esistono algoritmi che funzionano bene sperimentalmente, quindi, nonostante la sua complessità teorica, rappresenta comunque una procedura utilizzabile nella pratica.

Ci sono alcuni punti critici da considerare in questo approccio computazionale:

\begin{itemize}
    \item È difficile fornire un limite inferiore al tempo di annealing (il tempo minimo necessario per raggiungere lo stato finale).
    \item In assenza di tale limite inferiore, la formulazione QUBO può essere considerata come un'euristica e non è possibile valutare in generale l'efficienza e la correttezza dell'algoritmo.
    \item Questo approccio non è valido in modo generale, poiché ci sono casi in cui gli algoritmi classici mostrano un comportamento lineare, mentre l'implementazione quantistica può degradare all'aumentare delle dimensioni del problema.
\end{itemize}

\subsection{Quantum Unconstraint Binary Optimization}
Il problema QUBO, Quadratic Unconstrained Binary Optimization, consiste nell'individuare il vettore $x^* = (x_1^*, \dots, x_n^*)$ che minimizza l'equazione $\bar{x}^tQ\bar{x}$, dove $\bar{x}$ è un vettore colonna di variabili binarie e $Q$ è una matrice triangolare superiore che rappresenta i coefficienti della funzione da minimizzare.

In particolare, l'obiettivo del problema QUBO è determinare il valore delle variabili binarie $x_i$ che minimizza l'espressione $\sum_{i=1}^{n} \sum_{j=1}^{n} Q_{ij} x_i x_j$, dove $Q_{ij}$ sono gli elementi della matrice $Q$.

\begin{center}
    minimizzare 
    $\underbrace{\begin{bmatrix}
        x_1 & \cdots & x_n 
    \end{bmatrix}}_{\bar{x}^T}$ 
    $\underbrace{\begin{bmatrix}
        a_1 & \cdots & a_3 \\
        \vdots & \ddots & b_3 \\
        0 & \cdots & c_3 
    \end{bmatrix}}_{Q}$ 
    $\underbrace{\begin{bmatrix}
        x_1 \\
        \vdots \\
        x_n 
    \end{bmatrix}}_{\bar{x}}$       
\end{center}

È importante notare che nella funzione obiettivo espansa, è possibile riscrivere i termini quadratici, cioè le variabili al quadrato, utilizzando il loro equivalente lineare. Questa riscrittura è possibile grazie al dominio delle variabili $x_i$, che assumono solo i valori 0 o 1. Pertanto, il termine $x_i^2$ può essere sostituito con $x_i$ nella formulazione del problema QUBO.

Il formalismo dei modelli QUBO offre un approccio flessibile per la risoluzione di problemi di ottimizzazione combinatoria mediante l'utilizzo di variabili binarie e l'espressione quadratica della funzione obiettivo. Questo formalismo è di particolare importanza nella progettazione e nell'implementazione di algoritmi e processori quantistici adiabatici per la risoluzione efficiente di problemi complessi.

\subsection{Simulated Annealing}

L'algoritmo del Simulated Annealing fornisce una prospettiva intuitiva sul funzionamento di un processore quantistico adiabatico, QCPU.

L'obiettivo di questo algoritmo è raggiungere lo stato finale attraverso un cammino casuale, Random Walk, attraverso tutti i possibili stati del sistema. La selezione dei passi da compiere è influenzata dalla probabilità che varia nel tempo e determina se accettare o meno le variazioni energetiche del sistema fisico su cui si sta operando.

Nell'implementazione di questo algoritmo, vengono utilizzati due attributi fondamentali: l'insieme degli stati adiacenti a un dato nodo e l'energia associata a tale nodo, questi parametri influenzano la sequenza di passi che porta al cammino e dunque allo stato finale.

Durante l'esecuzione dell'algoritmo, un parametro cruciale è rappresentato dalla temperatura, che può decrescere secondo diverse funzioni, più o meno rapidamente, con la diminuzione della temperatura si otterrà una conseguente stabilizzazione su uno degli stati, che quindi rappresenterà la risposta.

\subsubsection*{Formalizzazione dell'algoritmo del Simulated Annealing}

Sia $G=(V,E)$ un grafo rappresentante il sistema fisico di interesse, dove $V$ rappresenta l'insieme dei nodi e $E$ l'insieme degli archi. Ogni nodo $v \in V$ ha associata un'energia $E(v)$, mentre l'insieme degli adiacenti di un nodo $v$ è indicato con $N(v)$.

L'algoritmo del Simulated Annealing può essere descritto attraverso i seguenti passaggi:

\begin{enumerate}
    \item Inizializzazione: si assegna a ogni nodo del grafo una configurazione casuale iniziale e si fissa una temperatura iniziale $T$.
    \item Ciclo principale:
    \begin{enumerate}
        \item Scelta di un nodo $v$ in modo casuale dal grafo.
        \item Selezione di un nodo $u$ in modo casuale dall'insieme $N(v)$.
        \item Calcolo della variazione di energia $\Delta E = E(u) - E(v)$.
        \item Se $\Delta E \leq 0$, si accetta la mossa e si aggiorna lo stato del sistema considerando $u$ come nuovo stato corrente.
        \item Se $\Delta E > 0$, si accetta la mossa con una probabilità $p = \exp(-\frac{\Delta E}{T})$. In caso di accettazione, si aggiorna lo stato del sistema come nel passo precedente.
        \item Ripeti i passi da (a) a (e) fino a soddisfare una condizione di terminazione.
    \end{enumerate}
\end{enumerate}

Durante l'esecuzione dell'algoritmo, la temperatura $T$ viene ridotta nel tempo seguendo una specifica funzione, che dipende dal problema e dall'obiettivo dell'ottimizzazione.

L'algoritmo del Simulated Annealing rappresenta un importante strumento per l'esplorazione degli spazi di ricerca complessi e ha trovato applicazioni significative nella risoluzione di problemi di ottimizzazione e nell'ambito della computazione quantistica adiabatica.

È importante notare che l'algoritmo del Simulated Annealing può essere implementato anche su processori quantistici adiabatici, sfruttando le peculiarità della computazione quantistica per ottenere potenziali vantaggi prestazionali.

\section{Min Cut come problema QUBO}

\subsection{Conversione delle variabili di surplus}

\subsection{Rilassamento Lagrangiano}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte 3 Implementazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementazione}

\subsection{Test}


\bibliographystyle{plain}
\bibliography{cite}
\end{document}